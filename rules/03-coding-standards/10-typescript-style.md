# 10 ‚Äì TypeScript/Vue Style Guide ‚Äì Progressive Enhancement Standards

**File Path:** rules/03-coding-standards/10-typescript-style.md  
**Domain:** Hybrid UI Architecture (Server-Rendered JTE Templates + Vue Enhancements)  
**Last Updated:** 2026-01-23  
**Status:** Active  

---

## üéØ Purpose  
Establish rigorous conventions for integrating Vue 3 as a client-side progressive enhancement layer atop server-rendered HTML generated by Spring Boot and JTE templates. Vue is restricted to targeted DOM interactions (e.g., real-time updates via WebSockets, form validation, animations) without rendering core page structure, implementing SPA routing, or using SSR. This ensures accessibility, SEO, and backend control over initial rendering while adding lightweight interactivity.

## üìå Scope  
- **Applies to:** External Vue/TypeScript scripts loaded via `<script>` tags; DOM-targeted enhancements in browser runtime.  
- **Excludes:** Vue Single File Components (SFCs), `vue-loader`, SSR frameworks (e.g., Nuxt), Vue Router, or full-page Vue mounts.  
- **Dependencies:**  
  - [JTE Template Standards + HTML/CSS Standards](../03-coding-standards/11-html-css-rules)  
  - [Java DTO Rules](../03-coding-standards/09-java-style.md)  
  - [Static Asset Versioning](../06-build/21-asset-management.md)  

---

## üß† Semantic Anchors  

### 1. Enhancement Zone Pattern  
Vue apps must mount exclusively to predefined DOM containers (e.g., `<div id="enhance-payment-status">`) in server-rendered HTML. This isolates enhancements and preserves static fallback content.  

```typescript  
// payment-status-enhancer.ts  
interface PaymentStatusDto {  
  id: string;  
  status: 'PENDING' | 'COMPLETED' | 'FAILED';  // Mirrors Java DTO exactly  
  timestamp: string;  
}  

/**  
 * @Semantic("ProgressiveEnhancer")  
 * @Vibe("Maintains server primacy; Vue as overlay only")  
 */  
export function mountPaymentStatusEnhancer(targetId: string, initialData: PaymentStatusDto): void {  
  const { createApp, ref } = (window as any).Vue;  // Global runtime import (no bundlers for SFCs)  
  
  const app = createApp({  
    setup() {  
      const status = ref(initialData.status);  
      const ws = new WebSocket(`/ws/payments/${initialData.id}`);  
      ws.onmessage = (evt: MessageEvent) => {  
        const update = JSON.parse(evt.data) as Partial<PaymentStatusDto>;  
        if (update.status) status.value = update.status;  
        // Targeted DOM update: avoids re-rendering entire zones  
        const label = document.getElementById('status-label');  
        if (label) label.textContent = update.status || status.value;  
      };  
      return { status };  
    },  
    template: `<span id="status-label">{{ status }}</span>`  // Scoped to zone; no outerHTML mutation  
  });  
  
  const el = document.getElementById(targetId);  
  if (el) {  
    app.mount(el);  
  } else {  
    console.warn(`Enhancement zone ${targetId} not found in DOM`);  
  }  
}  
```  

### 2. Type Enforcement Rules  
- **DTO Mirroring:** All TypeScript interfaces must replicate Java DTOs 1:1, including enums and optionals. Use OpenAPI generators for synchronization.  
- **DOM Safety & Guards:** Employ type assertions with runtime validation; ban implicit `any`.  
- **Strict Mode:** Enforce `noImplicitAny: true` and `strictNullChecks: true` in `tsconfig.json`.  

```typescript  
// Type guard for deserializing server data  
function isPaymentStatusDto(obj: unknown): obj is PaymentStatusDto {  
  return typeof obj === 'object' && obj !== null &&  
         'id' in obj && typeof (obj as any).id === 'string' &&  
         'status' in obj && typeof (obj as any).status === 'string';  
}  

// Safe DOM accessor  
function getValidatedElement<T extends HTMLElement>(id: string): T | null {  
  const el = document.getElementById(id);  
  if (!el) throw new Error(`Missing enhancement zone: ${id}`);  
  return el as T;  
}  
```  

### 3. Lifecycle Management  
- **Initialization Timing:** Trigger enhancers only after `DOMContentLoaded` to respect server-rendered order.  
- **Cleanup:** Unmount on page unload to prevent memory leaks in multi-page navigation.  
```typescript  
document.addEventListener('DOMContentLoaded', () => {  
  const container = getValidatedElement<HTMLDivElement>('enhance-payment-status');  
  const rawData = container.dataset.initialData;  
  if (rawData) {  
    const initialData = JSON.parse(rawData);  
    if (isPaymentStatusDto(initialData)) {  
      mountPaymentStatusEnhancer('enhance-payment-status', initialData);  
    }  
  }  
});  

window.addEventListener('beforeunload', () => {  
  // Unmount logic: app.unmount() for each active instance  
});  
```  

---

## üîß Technical Specifications  

### 1. HTML/JTE Integration  
Server templates provide static fallbacks and data attributes for enhancers:  
```html  
<!-- JTE template: templates/payments.jte -->  
<div id="enhance-payment-status"  
     data-initial-data="${jte.escapeJson(paymentDto)}">  
  <!-- Static fallback for no-JS scenarios -->  
  <span id="status-label">${paymentDto.status}</span>  
  <div>Updated: ${paymentDto.timestamp}</div>  
</div>  

<script defer src="/static/v1.2.3/js/payment-status-enhancer.js"></script>  
```  

### 2. Reactive Data Flow  
- **Initial Hydration:** Parse `data-*` attributes from server-serialized JSON.  
- **Live Sync:** Use WebSockets/SSE for updates; apply surgically to DOM nodes without Vue re-rendering the entire page.  
- **No State Persistence:** Enhancers reset on full page loads (Spring Boot routing).  

### 3. Build & Asset Strategy  
Integrate TypeScript compilation into Gradle for versioned static assets:  
```kotlin  
// build.gradle.kts (in frontend submodule)  
tasks.register("buildEnhancements") {  
  dependsOn("compileTypeScript")  
  inputs.dir("src/main/ts")  
  outputs.dir("build/resources/main/static/v${project.version}/js")  
  
  doLast {  
    exec {  
      commandLine("npm", "run", "build:ts")  // tsc or esbuild  
    }  
    copy {  
      from("dist/js")  
      into("build/resources/main/static/v${project.version}/js")  
      include("**/*.js")  
    }  
  }  
}  

tasks.register("verifyEnhancementArch") {  
  dependsOn("buildEnhancements")  
  doLast {  
    val forbidden = listOf(  
      "createApp.*mount\\(document.body",  // No full-page mounts  
      "innerHTML\\s*="  // Limit mutations  
    )  
    forbidden.forEach { pattern ->  
      exec {  
        commandLine("grep", "-rn", pattern, "src/main/ts")  
        isIgnoreExitValue = true  
      }.let { execResult ->  
        if (execResult.exitValue == 0) {  
          throw GradleException("Forbidden pattern detected: $pattern")  
        }  
      }  
    }  
  }  
}  
```  

---

## ‚öôÔ∏è Enforcement Mechanics  

| Rule                       | Tool/Mechanism                  | Action                                      |  
|----------------------------|---------------------------------|---------------------------------------------|  
| No SFCs or SPA Features    | ESLint (vue/eslint-plugin-vue)  | Error on `.vue` files or `VueRouter` imports|  
| Scoped Mounts Only         | Custom ESLint Rule + AST Scan   | Fail if `mount()` targets `body` or `#app`  |  
| DTO Type Consistency       | OpenAPI Generator + tsc         | Auto-regenerate TS types; fail on mismatches|  
| DOM Mutation Limits        | ESLint (no-inner-html)          | Warn/error on `innerHTML`/`outerHTML` usage |  
| Asset Versioning           | Gradle Task                     | Build fails without `/static/vX.Y.Z/` paths |  
| Late Initialization        | Custom Script Validator         | Ensure all enhancers use `DOMContentLoaded` |  

**CI/CD Integration:**  
- Pre-commit hooks run ESLint and TypeScript checks.  
- Gradle tasks (`buildEnhancements`, `verifyEnhancementArch`) execute in CI pipeline.  
- Bundle analyzer ensures single global Vue runtime import (no duplicates).  

---

## üìã Compliance Checklist  
- [ ] Vue initialization waits for `DOMContentLoaded`.  
- [ ] All mounts target enhancement zones (e.g., `#enhance-*`).  
- [ ] No Vue-generated HTML for core structure; only overlays dynamic elements.  
- [ ] TypeScript types generated/mirrored from Java DTOs via OpenAPI.  
- [ ] Enhancers include unmount logic for page navigation.  
- [ ] Static assets served from versioned paths (e.g., `/static/v1.2.3/js/`).  
- [ ] E2E tests confirm graceful degradation without JS.  

---

## üîó Interlocks  
- **Backend Alignment:** JTE templates must embed enhancement zones and serialize DTOs to `data-*` attributes. DTO changes trigger TS regeneration.  
- **Testing Suite:** Unit tests for type guards; E2E verifies server HTML integrity post-enhancement.  
- **Build Pipeline:** Frontend build depends on backend DTO compilation; version sync via Gradle properties.  

**Revision Lock:** Modifications to patterns (e.g., zone naming, type mirroring) require review by backend and frontend leads.  

---

## üìú Revision History  
| Version | Date       | Author        | Changes Summary                          |  
|---------|------------|---------------|------------------------------------------|  
| 1.0     | 2026-01-23 | LLM-Generated | Initial spec for hybrid enhancement arch |  

---

## Implementation Guide  
1. **Backend Setup (Spring/JTE):**  
   - Controller populates model with DTOs.  
   - JTE: Add zones with `data-initial-data="${jte.escapeJson(dto)}"`.  
   ```java  
   @GetMapping("/payments/{id}")  
   String viewPayment(@PathVariable String id, Model model) {  
     model.addAttribute("paymentDto", paymentService.getById(id));  
     return "payments";  // Renders JTE  
   }  
   ```  

2. **Frontend Enhancer Development:**  
   - Write modular TS functions (e.g., `mountPaymentStatusEnhancer`).  
   - Use global Vue runtime: `<script src="/static/vue.runtime.global.js"></script>`.  

3. **Build & Deploy:**  
   - Run `./gradlew buildEnhancements` to compile TS and version assets.  
   - Deploy to Spring's `/static/` for automatic serving.  

4. **Verification:**  
   - `./gradlew verifyEnhancementArch` for architecture compliance.  
   - Browser dev tools: Confirm no Vue errors on JS-disabled loads.  
   - Add WebSocket mocks for unit testing real-time flows.  

**Key Principles:** Backend owns rendering and routing; Vue enhances surgically. This hybrid approach scales maintainability without SPA overhead, ensuring fast initial loads and robust fallbacks.